# goit-algo-hw-04
# Порівняння алгоритмів сортування: Merge Sort, Insertion Sort та Timsort

## Опис завдання

У цьому завданні було порівняно три алгоритми сортування: сортування злиттям (Merge Sort), сортування вставками (Insertion Sort) та Timsort (вбудоване в Python сортування). Ми вимірювали час виконання цих алгоритмів на різних наборах даних, використовуючи модуль `timeit`. Мета цього аналізу полягала в тому, щоб продемонструвати, наскільки ефективнішим є Timsort у порівнянні з іншими алгоритмами.

## Використані алгоритми

1. **Merge Sort (Сортування злиттям)**
   - Алгоритм сортування злиттям використовує підхід "розділяй і владарюй", розбиваючи масив на менші частини і зливаючи їх у відсортованому порядку.
   - Теоретична складність: `O(n log n)`.

2. **Insertion Sort (Сортування вставками)**
   - Сортування вставками працює шляхом послідовного проходу масиву і вставки кожного елемента у відсортоване місце.
   - Теоретична складність: `O(n^2)` у найгіршому випадку.

3. **Timsort**
   - Timsort — це гібридний алгоритм сортування, який поєднує сортування злиттям і сортування вставками, що робить його надзвичайно ефективним для різних типів даних.
   - Використовується у вбудованій функції `sorted()` в Python.
   - Теоретична складність: `O(n log n)` у середньому і найгіршому випадку.

## Порівняння ефективності

Ми провели емпіричний аналіз, порівнюючи три алгоритми на різних розмірах даних: 100, 1000, 5000 і 10000 елементів. Для кожного алгоритму було виміряно час виконання. Результати виведені у вигляді таблиці.

### Результати
- **Merge Sort** показав хорошу ефективність на великих наборах даних, але все ж поступався Timsort.
- **Insertion Sort** виявився значно менш ефективним на великих наборах даних через квадратичну складність `O(n^2)`. Він був придатним лише для малих масивів.
- **Timsort** був найбільш ефективним серед трьох алгоритмів завдяки поєднанню сортування злиттям і сортування вставками, що забезпечило оптимальну швидкість для різних типів наборів даних.

### Таблиця результатів

| Розмір даних | Merge Sort (секунди) | Insertion Sort (секунди) | Timsort (секунди) |
|--------------|----------------------|--------------------------|-------------------|
| 100          | Результат для Merge Sort | Результат для Insertion Sort | Результат для Timsort |
| 1000         | Результат для Merge Sort | Результат для Insertion Sort | Результат для Timsort |
| 5000         | Результат для Merge Sort | Результат для Insertion Sort | Результат для Timsort |
| 10000        | Результат для Merge Sort | Результат для Insertion Sort | Результат для Timsort |

## Висновки

- **Timsort** значно ефективніший для сортування великих масивів даних, що пояснює, чому він використовується як вбудований алгоритм сортування в Python. Поєднання сортування злиттям і сортування вставками робить Timsort ефективним як для випадкових даних, так і для вже частково відсортованих.
- **Сортування вставками** не є підходящим для великих наборів даних через високу складність `O(n^2)`. Однак на малих масивах алгоритм може бути досить ефективним завдяки своїй простоті.
- **Сортування злиттям** має кращу складність, ніж сортування вставками, і показує стабільно добрі результати, але поступається Timsort через відсутність додаткової оптимізації для частково відсортованих масивів.

Цей аналіз підтверджує, що використання вбудованих функцій сортування Python є найкращим вибором для більшості практичних завдань, де потрібна швидкість та ефективність.

## Додаткове завдання
У рамках додаткового завдання було реалізовано функцію `merge_k_lists`, яка об'єднує `k` відсортованих списків у один. Ця функція була реалізована без використання модуля `heapq`, що забезпечує ефективне злиття кількох відсортованих списків. Алгоритм працює шляхом поетапного об'єднання списків, використовуючи ідею злиття у сортуванні злиттям.

### Приклад використання

Функція `merge_k_lists` дозволяє об'єднувати кілька відсортованих списків в один відсортований список, використовуючи ітеративний підхід для поетапного об'єднання всіх списків. Це забезпечує зрозумілу та ефективну реалізацію без використання додаткових бібліотек.

### Висновок щодо додаткового завдання
Ця реалізація показує, що навіть без використання спеціалізованих модулів можна реалізувати ефективний алгоритм для злиття кількох відсортованих списків, використовуючи підходи, аналогічні сортуванню злиттям. Такий підхід забезпечує гнучкість та можливість керувати процесом об'єднання, роблячи його зрозумілим для розробників.